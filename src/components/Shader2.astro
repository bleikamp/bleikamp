<style>
  .shader2-canvas {
    @apply w-full h-full;
    background-color: #000;
  }
</style>

<canvas id="webgl-canvas-2" class="shader2-canvas cursor-none"></canvas>

<script>
  const canvas2 = document.getElementById("webgl-canvas-2");
  const gl2 = canvas2.getContext("webgl");

  let mouseXVel2 = 0;
  let mouseYVel2 = 0;
  let lastMouseX2 = 0.5;
  let lastMouseY2 = 0.5;
  let velocityDecay2 = 0.01;

  function resizeCanvas2() {
    canvas2.width = window.innerWidth * 0.3;
    canvas2.height = window.innerWidth * 0.3;
    gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
  }

  window.addEventListener("resize", () => {
    resizeCanvas2();
  });

  resizeCanvas2();

  function createShader2(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader2 compile failed:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram2(gl, vertexSource, fragmentSource) {
    const vShader = createShader2(gl, gl.VERTEX_SHADER, vertexSource);
    const fShader = createShader2(gl, gl.FRAGMENT_SHADER, fragmentSource);

    const program = gl.createProgram();
    gl.attachShader(program, vShader);
    gl.attachShader(program, fShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Program2 link failed:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
      return null;
    }

    return program;
  }

  const vertexSource2 = `
    attribute vec2 a_position;
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentSource2 = `
    precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform vec2 u_mouseVelocity;

        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        vec3 getGradient(vec2 uv) {
            vec2 mouse = u_mouse + u_mouseVelocity * 0.5;
            vec3 orange = vec3(u_mouse.x, sin(u_time), cos(u_time));
            vec3 pink = vec3(1.0, 0.2, 0.5);
            vec3 yellow = vec3(1.0, u_mouse.y, sin(u_time));

            float n = noise(uv * 3.0 + u_time * 0.2);
            n += noise(uv * 6.0 - u_time * 0.1) * 0.5;
            n = n / 1.5;

            float t = uv.x * 0.5 + uv.y * 0.5 + n * 0.3;

            vec3 color;
            if (t < 0.5) {
                color = mix(orange, pink, smoothstep(0.0, 0.5, t));
            } else {
                color = mix(pink, yellow, smoothstep(0.5, 1.0, t));
            }

            return color;
        }

        float getCircle(vec2 uv, float radius, float blur) {
            float d = length(uv);
            return smoothstep(radius + blur, radius - blur, d);
        }

        float getMouseInfluence(vec2 st, vec2 mouse) {
            vec2 mousePos = mouse * 2.0 - 1.0;
            mousePos.x *= u_resolution.x/u_resolution.y;

            float dist = length(st - mousePos);
            float radius = 2.5; // Size of mouse influence
            return smoothstep(radius, 0.0, dist);
        }

        vec2 getDistortion(vec2 st, vec2 mouse, float mouseInfluence) {
            // Create noise-based distortion
            float noiseTime = u_time * 0.5;
            float distortionNoise = noise(st * 4.0 + noiseTime) * 2.0 - 1.0;
            distortionNoise += (noise(st * 8.0 - noiseTime) * 2.0 - 1.0) * 0.5;

            // Calculate direction from mouse to current position
            vec2 mousePos = mouse * 2.0 - 1.0;
            mousePos.x *= u_resolution.x/u_resolution.y;
            vec2 directionToMouse = normalize(st - mousePos);

            // Create distortion vector
            vec2 distortion = directionToMouse * distortionNoise * 0.05;

            // Apply mouse influence to distortion
            return distortion * mouseInfluence;
        }

        void main() {
            vec2 uv = gl_FragCoord.xy/u_resolution.xy;
            vec2 st = uv * 2.0 - 1.0;
            st.x *= u_resolution.x/u_resolution.y;

            // Get mouse influence
            float mouseInfluence = getMouseInfluence(st, u_mouse);

            // Apply distortion to coordinates
            vec2 distortion = getDistortion(st, u_mouse, mouseInfluence);
            vec2 distortedSt = st + distortion;

            // Base blur amount plus mouse-influenced blur
            float baseBlur = 0.01;
            float maxBlur = 0.1;
            float blur = baseBlur + (maxBlur * mouseInfluence);

            // Get circle with variable blur using distorted coordinates
            float circle = getCircle(distortedSt, 0.3, blur);

            // Get gradient colors
            vec3 gradientColor = getGradient(distortedSt + 0.5);

            // Apply circle mask with gradient
            vec3 finalColor = gradientColor * circle;

            gl_FragColor = vec4(finalColor, circle);
        }

  `;

  const program2 = createProgram2(gl2, vertexSource2, fragmentSource2);

  const aPositionLocation2 = gl2.getAttribLocation(program2, "a_position");
  const uResolutionLocation2 = gl2.getUniformLocation(program2, "u_resolution");
  const uTimeLocation2 = gl2.getUniformLocation(program2, "u_time");
  const uMouseLocation2 = gl2.getUniformLocation(program2, "u_mouse");
  const uMouseVelocityLocation2 = gl2.getUniformLocation(
    program2,
    "u_mouseVelocity",
  );

  let mouseX2 = 0.5;
  let mouseY2 = 0.5;

  canvas2.addEventListener("mousemove", (e) => {
    const rect = canvas2.getBoundingClientRect();
    const newMouseX = (e.clientX - rect.left) / rect.width;
    const newMouseY = 1.0 - (e.clientY - rect.top) / rect.height;

    mouseXVel2 = (newMouseX - lastMouseX2) * 2.0;
    mouseYVel2 = (newMouseY - lastMouseY2) * 2.0;

    lastMouseX2 = mouseX2;
    lastMouseY2 = mouseY2;
    mouseX2 = Math.max(0, Math.min(1, newMouseX));
    mouseY2 = Math.max(0, Math.min(1, newMouseY));
  });

  canvas2.addEventListener("mouseleave", () => {
    mouseX2 = 0.5;
    mouseY2 = 0.5;
  });

  const positionBuffer2 = gl2.createBuffer();
  gl2.bindBuffer(gl2.ARRAY_BUFFER, positionBuffer2);
  const positions2 = new Float32Array([
    -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1,
  ]);
  gl2.bufferData(gl2.ARRAY_BUFFER, positions2, gl2.STATIC_DRAW);

  gl2.useProgram(program2);
  gl2.enableVertexAttribArray(aPositionLocation2);
  gl2.vertexAttribPointer(aPositionLocation2, 2, gl2.FLOAT, false, 0, 0);

  let startTime2 = performance.now();
  function render2() {
    const now = performance.now();
    const time = (now - startTime2) * 0.001;

    mouseXVel2 *= velocityDecay2;
    mouseYVel2 *= velocityDecay2;

    gl2.uniform2f(uMouseLocation2, mouseX2, mouseY2);
    gl2.uniform2f(
      uResolutionLocation2,
      gl2.drawingBufferWidth,
      gl2.drawingBufferHeight,
    );
    gl2.uniform1f(uTimeLocation2, time);
    gl2.uniform2f(uMouseVelocityLocation2, mouseXVel2, mouseYVel2);

    gl2.clearColor(0.0, 0.0, 0.0, 1.0);
    gl2.clear(gl2.COLOR_BUFFER_BIT);

    gl2.drawArrays(gl2.TRIANGLES, 0, 6);

    requestAnimationFrame(render2);
  }

  render2();
</script>
